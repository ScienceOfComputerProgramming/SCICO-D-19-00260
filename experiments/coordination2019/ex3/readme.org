# -*- org-confirm-babel-evaluate: nil; -*-

* Choreography
A different problem affects this example. 
Here the two branches describe different orders of the same set of
events. The behaviour of *a* (and *d*) is the same in both branches: *a*
(resp. *d*) concurrently sends message *x* (resp.  *y*)
to *b* and *c*.
%
The behaviors of *b* and *c* differ: in
the left branch they first receive the message
from *a* then the one from *d*, in
the right branch, they have the same interactions
but in opposite order.
%
This choreography cannot be realised since, intuitively, it requires
*b* and *c* to commit on the same order of reception without
communicating with each other.

#+begin_src python :session coordination :results output replace drawer :hlines yes
def gen_graph_choice_par(a_before_d):
  gr = nx.DiGraph()
  abx = add_pair(gr, "a", "b", 1, "x")
  dby = add_pair(gr, "d", "b", 2, "y")
  acx = add_pair(gr, "a", "c", 3, "x")
  dcy = add_pair(gr, "d", "c", 4, "y")
  if a_before_d:
    gr.add_edge(acx[1], dcy[1])
    gr.add_edge(abx[1], dby[1])
  else:
    gr.add_edge(dcy[1], acx[1])
    gr.add_edge(dby[1], abx[1])
  return gr

global_view = [gen_graph_choice_par(False), gen_graph_choice_par(True)]
debug_graphs(global_view, "test-coordination/3/global-view")
#+end_src





* CC2
#+begin_src python :session coordination
cc2c = cc2closure(global_view)
cc2res = cc2pom(cc2c, global_view)
cc2err = counterexamples(cc2c, cc2res)
len(cc2err)
#+end_src


#+begin_src python :session coordination :results output drawer replace
debug_graphs(cc2err, "test-coordination/3/cc2-errors")
#+end_src









